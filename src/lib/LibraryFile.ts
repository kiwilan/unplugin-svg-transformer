import { dirname } from 'node:path'
import { symlink } from 'node:fs/promises'
import { runInThisContext } from 'node:vm'
import type { OptionsExtended } from '../types'
import type { SvgItem } from './Svg/SvgItem'
import { Path } from './Path'

export class LibraryFile {
  protected constructor(
    protected items: SvgItem[] = [],
    protected list?: string,
    protected types?: string,
    protected options: OptionsExtended = {},
    protected extension = 'ts',
  ) { }

  public static async make(items: SvgItem[], options: OptionsExtended): Promise<LibraryFile> {
    const self = new LibraryFile(items)

    self.extension = options.useTypes ? 'ts' : 'js'
    self.options = options
    self.list = await self.setList()
    self.types = await self.setTypes()

    return self
  }

  public getItems(): SvgItem[] {
    return this.items
  }

  public getList(): string {
    return this.list!
  }

  public getTypes(): string {
    return this.types!
  }

  private content(): string {
    let content = [
      '/* eslint-disable eslint-comments/no-unlimited-disable */',
      '/* eslint-disable */',
      '/* prettier-ignore */',
      '// @ts-nocheck',
      '// Generated by unplugin-svg-transformer',

    ]

    if (this.options.useTypes) {
      content = [
        ...content,
        `export ${this.types}`,
      ]
    }

    content = [
      ...content,
      this.list!,
    ]

    return content.join('\n')
  }

  private async update(path: string, window = true): Promise<string> {
    this.list = await this.setList(path, window, this.options.useTypes)
    if (!this.options.useTypes)
      this.types = ''

    return this.list
  }

  private async setTypes(): Promise<string> {
    let content = ''
    content += 'type SvgType = '
    this.items.forEach((item, key) => {
      if (key > 0)
        content += ' | '

      content += `'${item.getName()}'`
    })

    if (this.items.length > 0)
      content += ' | \'default\''
    else
      content += '\'default\''

    content = content.replace('\'default\' | \'default\'', '\'default\'')

    return content
  }

  private async setList(basePath = '', window = true, typescript = true): Promise<string> {
    const content = []

    if (typescript)
      content.push('export const svgList: Record<SvgType, () => Promise<{ default: string }>> = {')
    else
      content.push('export const svgList = {')

    this.items.forEach((item) => {
      const localPath = item.getPath()
      let path = Path.normalizePaths([basePath, localPath])
      if (this.options.isNuxt)
        path = `./.nuxt/icons${localPath}`

      path = path.replace('.svg', '')

      content.push(`  '${item.getName()}': () => import('${path}'),`)
    })

    content.push('}')

    content.push('')

    if (this.options.useTypes)
      content.push('export async function importSvg(name: SvgType): Promise<string> {')
    else
      content.push('export async function importSvg(name) {')

    content.push('  if (!svgList[name])')
    // eslint-disable-next-line no-template-curly-in-string
    content.push('    console.warn(`Icon ${name} not found`)')
    content.push('  name = svgList[name] || svgList["default"]')
    content.push('  const svg = await name()')
    content.push('  if (svg.default)')
    content.push('    return svg.default')
    content.push('  return svg')
    content.push('}')

    if (window && !this.options.isNuxt) {
      content.push('')
      content.push('if (typeof window !== \'undefined\') {')
      // content.push('  // @ts-expect-error type is global')
      content.push('  window.svgList = svgList')
      content.push('  window.importSvg = importSvg')
      content.push('}')
    }

    return content.join('\n')
  }

  /**
   * Write library file, `icon.ts`.
   */
  private async write(directory: string, filename: string, cache: string): Promise<boolean> {
    directory = Path.normalizePaths(`${directory}/`)
    filename = `${filename}.${this.extension}`
    const path = `${directory}${filename}`

    if (await Path.fileExists(path))
      await Path.rm(path)

    await this.update(cache, true)
    const content = this.content()

    const dir = dirname(path)
    await Path.ensureDirectoryExists(dir)

    return await Path.write(path, content)
  }

  public async writeAll(rootLibraryDir: string): Promise<void> {
    const cache = await Path.relativeToNodeModules(rootLibraryDir)
    const packageLibraryDir = Path.packagePath({ dist: true })
    if (this.options.isNuxt) {
      rootLibraryDir = Path.rootPath()
      await this.symLink(`${rootLibraryDir}/icons.${this.extension}`, `${this.options.nuxtDir!}/icons.${this.extension}`)
    }

    await this.write(rootLibraryDir, 'icons', cache)
    await this.symLink(`${rootLibraryDir}/icons.${this.extension}`, `${packageLibraryDir}/icons.${this.extension}`)
  }

  private async symLink(target: string, link: string): Promise<void> {
    target = Path.normalizePaths(target)
    link = Path.normalizePaths(link)
    await Path.rm(link)
    await symlink(target, link)
  }
}
